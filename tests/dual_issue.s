######### Generated by Gemini and other AI models #########



########################


# 96 cycles for pipelined

# Register Usage:
# x2 (sp): Stack Pointer
# x5: Base address of the array (arr_ptr)
# x6: Current array element value / temp register
# x7: Loop counter / array index (i)
# x8: The loop bound (N)
# x9: Accumulated sum (sum)
# x10: Holds the constant 4 (for byte offset calculation)

.text

main:
    # --- Stack Setup and Initialization (Replacing %lo/%hi) ---

    # We need 8 words (32 bytes) for the array and 1 word (4 bytes) for N.
    # Total space needed: 36 bytes.
    addi sp, sp, 1000
    addi sp, sp, 1000

    # Initialize N (Loop Bound = 8) at sp + 32
    addi x8, x0, 8           # x8 = 8 (The value)
    sw x8, 32(sp)            # Store N at sp + 32

    # Initialize Array values (10, 20, 30, ...) starting at sp
    addi x6, x0, 10
    sw x6, 0(sp)             # array[0] = 10
    addi x6, x0, 20
    sw x6, 4(sp)             # array[1] = 20
    # ... and so on for the rest of the 8 elements

    # Get the base address of the array
    addi x5, sp, 0           # x5 = Base address of array (now the stack base)

    # Load N back from the stack
    lw x8, 32(sp)            # x8 = N (Loop bound = 8)

    # --- Dual-Issue Setup ---
    addi x10, x0, 4          # x10 = 4 (Word size constant)
    addi x7, x0, 0           # x7 = i = 0 (Loop counter)
    addi x9, x0, 0           # x9 = sum = 0

Loop:
    # --- Dual-Issue Optimization Starts Here ---
    # Paired 1: Independent ALU operations (Calculating offset for current load & incrementing counter for next check)
    slli x6, x7, 2           # x6 = i * 4 (Calculate byte offset)
    addi x7, x7, 1           # x7 = i + 1 (Increment loop counter for NEXT iteration)

    # Sequential 1: Address calculation and Load (Load depends on Address)
    add x6, x5, x6           # x6 = array_base + offset (Full address)
    lw x6, 0(x6)             # x6 = array[i] (Load word from memory)

    # Paired 2: Independent operations (Summation and Branch Check)
    add x9, x9, x6           # x9 = sum + array[i] (Accumulate sum)
    bne x7, x8, Loop         # Branch if i != N (Check condition)

End:
    addi sp, sp, 36          # Deallocate stack space (cleanup)

nop
nop
nop
nop
nop
nop
nop